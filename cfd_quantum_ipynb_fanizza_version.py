# -*- coding: utf-8 -*-
"""CFD_quantum.ipynb - Fanizza Version

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gbwQ4Cgtz2vp9fvqM0ng4A0uOJTy_GYF
"""

!pip install tntorch

pip install --upgrade pennylane

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

import torch

"""Run command
python -u script/simulation_script.py 1.5 10 3e-3 2e-3 circle 8 7

# Solving the Hydrodynamic Schrödinger Equation?
"""

# This is for importing the PennyLane library for quantum computing
import pennylane as qml
# This is for importing NumPy for numerical operations
import numpy as np
# This is for importing Matplotlib for plotting results
import matplotlib.pyplot as plt
# This is for importing SymPy for symbolic math printing
import sympy as sp

# This is for setting the number of qubits / discrete spatial points
Nx = 8
# This is for defining the number of layers in the quantum circuit ansatz
layers = 3

# This is for creating a quantum device with Nx qubits using PennyLane's default simulator
dev = qml.device("default.qubit", wires=Nx)

# This is for defining the target wavefunction we want the quantum circuit to approximate
def target_wavefunction(Nx):
    # This is for computing number of computational basis states (2^Nx)
    num_computational_states = 2**Nx
    # This is for creating evenly spaced points between 0 and 1
    x_points = np.linspace(0, 1, num_computational_states)
    # This is for setting the center of the Gaussian wavefunction
    x0 = 0.5
    # This is for setting the width of the Gaussian
    sigma = 0.1
    # This is for calculating Gaussian values as amplitudes
    amplitudes = np.exp(- (x_points - x0)**2 / (2 * sigma**2))
    # This is for normalizing the amplitudes to create a valid quantum state
    psi0 = amplitudes / np.linalg.norm(amplitudes)
    # This is for returning the target wavefunction
    return psi0

# This is for storing the target wavefunction and converting it to a PennyLane-compatible array
target_psi = target_wavefunction(Nx)
target_psi = qml.numpy.array(target_psi, requires_grad=False)

# This is for defining the quantum circuit ansatz using layered rotations and entanglements
def layered_schrodinger_ansatz(params, a, m):
    # This is for iterating over each layer
    for layer in range(layers):
        # This is for applying parameterized rotations to each qubit
        for i in range(Nx):
            qml.RY(a * params[layer, i, 0], wires=i)
            qml.RZ(m * params[layer, i, 1], wires=i)
        # This is for adding entanglement between adjacent qubits
        for i in range(Nx - 1):
            qml.CNOT(wires=[i, i + 1])

# This is for defining the quantum node to return the state vector from the ansatz
@qml.qnode(dev)
def wavefunction_qnode(params, a, m):
    # This is for applying the ansatz
    layered_schrodinger_ansatz(params, a, m)
    # This is for returning the final quantum state
    return qml.state()

# This is for extracting physical quantities from the quantum state using the Madelung transformation
def madelung_from_state(state, m=1.0):
    # This is for using the input quantum state
    psi = state
    # This is for computing the probability density
    rho = qml.math.abs(psi)**2
    # This is for extracting the phase of each amplitude
    phase = qml.math.angle(psi)
    # This is for computing the spatial gradient of the phase
    dphase_dx = qml.math.gradient(phase)
    # This is for safe velocity calculation: avoid division by zero for m=0 safely
    safe_m = m if abs(qml.math.toarray(m).item()) > 1e-8 else 1e-8
    v = dphase_dx / safe_m
    # This is for returning density and velocity
    return rho, v

# This is for computing the fidelity (overlap) between two quantum states
def fidelity(state1, state2):
    # This is for computing inner product of state1 and state2
    overlap = qml.math.sum(qml.math.conj(state1) * state2)
    # This is for returning squared magnitude of the overlap
    return qml.math.abs(overlap)**2

# This is for computing the residual of the Burgers equation
def burgers_residual(v):
    # This is for computing the spatial derivative of velocity
    dv_dx = qml.math.gradient(v)
    # This is for computing the nonlinear term of the equation
    residual = v * dv_dx
    # This is for returning mean squared residual
    return qml.math.mean(residual**2)

# This is for computing penalty at the boundary of the wavefunction
def boundary_penalty(state):
    # This is for penalizing probability at the first and last basis state
    penalty = qml.math.abs(state[0])**2 + qml.math.abs(state[2**Nx - 1])**2
    return penalty

# Global step counter for printing inside loss_fn
global_step = 0

# This is for printing the Madelung equation symbolically with a and m plugged in
def print_madelung_equation(a_val, m_val):
    # Define symbolic variables
    rho, v, P, t, hbar = sp.symbols('rho v P t hbar')
    laplacian = sp.Function('∇²')
    gradient = sp.Function('∇')

    # Proper quantum potential coefficient
    quantum_potential_coeff = (hbar**2) / (4 * m_val)
    quantum_potential = quantum_potential_coeff * laplacian(sp.log(rho))

    # Build left and right hand side of equation
    lhs = rho * sp.Derivative(v, t) + sp.Symbol('(v ⋅ ∇)v')
    rhs = -gradient(P + quantum_potential)

    eq = sp.Eq(lhs, rhs)

    # Substitute ℏ = 1 for simplicity in print
    eq = eq.subs(hbar, 1)

    print("\n--- Madelung Equation with a = {}, m = {} (ℏ = 1) ---".format(a_val, m_val))
    sp.pprint(eq, use_unicode=True)
    print("-----------------------------------------------------\n")

# This is for computing the total loss function used for training the quantum circuit
def loss_fn(params, a, m, alpha=10, beta=50):
    global global_step

    # Warn if m is zero or near zero
    if abs(qml.math.toarray(m).item()) < 1e-7:
        print("Warning: m is zero or near zero, using safe epsilon for velocity calculation")

    # This is for computing the state from current parameters
    state = wavefunction_qnode(params, a, m)
    # This is for extracting density and velocity using Madelung transformation
    rho, v = madelung_from_state(state, m)

    dv_dx = qml.math.gradient(v)
    residual = v * dv_dx

    # Print detailed Burgers stuff every 10 steps to check it's working
    if global_step % 10 == 0:
        print(f"Step {global_step}: Burgers Residual (first 5 values): {qml.math.toarray(residual)[:5]}")
        print(f"Step {global_step}: Velocity Gradient (first 5 values): {qml.math.toarray(dv_dx)[:5]}")
        print(f"Step {global_step}: Mean squared residual: {qml.math.toarray(qml.math.mean(residual**2))}")

    # Extra: At first step print symbolic equation + current numeric results
    if global_step == 0:
        # Convert PennyLane ArrayBox to float safely
        a_val = qml.math.toarray(a).item()
        m_val = qml.math.toarray(m).item()
        print_madelung_equation(a_val, m_val)
        print(f"Numeric values at step 0 for a={a_val}, m={m_val}:")
        print(f"  Density (first 5): {qml.math.toarray(rho)[:5]}")
        print(f"  Velocity (first 5): {qml.math.toarray(v)[:5]}")
        print(f"  Burgers Residual (first 5): {qml.math.toarray(residual)[:5]}")

    global_step += 1

    # This is for computing Burgers residual loss
    burgers_loss = burgers_residual(v)
    # This is for computing fidelity loss
    init_fidelity = fidelity(state, target_psi)
    # This is for computing boundary penalty
    boundary_loss = boundary_penalty(state)
    # This is for computing total weighted loss
    total_loss = burgers_loss + alpha * (1 - init_fidelity) + beta * boundary_loss

    # This is for returning the total loss for optimization
    return total_loss

# This is for setting the random seed for reproducibility
np.random.seed(42)
# This is for initializing ansatz parameters near zero
params = 0.01 * np.random.randn(layers, Nx, 2)
# This is for initializing scaling parameters
a = 1.0
m = 1.0

# This is for converting to differentiable PennyLane arrays
params = qml.numpy.array(params, requires_grad=True)
a_param = qml.numpy.array(a, requires_grad=True)
m_param = qml.numpy.array(m, requires_grad=True)

# This is for setting up the optimizer
opt = qml.AdamOptimizer(stepsize=0.05)

# This is for storing optimization history
loss_history = []
a_history = []
m_history = []
# This is for defining number of optimization steps
num_steps = 50

# This is for enabling live plotting
plt.ion()
# This is for creating subplot layout
fig, axs = plt.subplots(1, 3, figsize=(15,4))
# This is for defining x-axis for plotting wavefunction quantities
plotting_x_points = np.linspace(0, 1, 2**Nx)

# This is for running the optimization loop
for step in range(num_steps):
    # This is for defining the cost function for optimizer
    def cost(p, a_, m_):
        return loss_fn(p, a_, m_)

    # This is for performing one optimization step and getting updated parameters and loss
    (updated_params, curr_loss) = opt.step_and_cost(cost, params, a_param, m_param)
    # This is for unpacking the updated parameters
    params, a_param, m_param = updated_params

    # This is for getting the current quantum state from the updated parameters
    state = wavefunction_qnode(params, a_param, m_param)
    # This is for extracting density and velocity using Madelung transformation
    rho, v = madelung_from_state(state, m_param)

    # This is for storing current loss and parameters
    loss_history.append(qml.math.toarray(curr_loss).item())
    a_history.append(qml.math.toarray(a_param).item())
    m_history.append(qml.math.toarray(m_param).item())

    # This is for printing clean stats every 5 steps or last step to reduce clutter
    if step % 5 == 0 or step == num_steps - 1:
        rho_arr = qml.math.toarray(rho)
        v_arr = qml.math.toarray(v)
        print(f"Step {step+1}:")
        print(f"  Density stats (Min): {rho_arr.min():.4f}, max: {rho_arr.max():.4f}, mean: {rho_arr.mean():.4f}")
        print(f"  Velocity stats (Min): {v_arr.min():.4f}, max: {v_arr.max():.4f}, mean: {v_arr.mean():.4f}")
        print(f"  Loss: {curr_loss:.6f}, a: {a_param:.4f}, m: {m_param:.4f}")

    # This is for clearing and redrawing each subplot properly
    axs[0].cla()
    axs[0].plot(loss_history, label='Loss')
    axs[0].set_title('Loss')
    axs[0].set_xlabel('Step')
    axs[0].set_ylabel('Loss')
    axs[0].legend()
    axs[0].grid(True)

    axs[1].cla()
    axs[1].plot(a_history, label='a')
    axs[1].plot(m_history, label='m')
    axs[1].set_title('Parameters a & m')
    axs[1].set_xlabel('Step')
    axs[1].set_ylabel('Value')
    axs[1].legend()
    axs[1].grid(True)

    axs[2].cla()
    axs[2].plot(plotting_x_points, rho, label='Density |ψ|²')
    axs[2].plot(plotting_x_points, v, label='Velocity (Madelung)')
    axs[2].set_title('Wavefunction Properties')
    axs[2].set_xlabel('x')
    axs[2].legend()
    axs[2].grid(True)

# This is for refreshing the plot properly
fig.canvas.draw()
fig.canvas.flush_events()

# This is for turning off interactive mode and showing the final plot
plt.ioff()
# This is for indicating optimization is done
print("Optimization complete!")
# This is for printing the final values of a and m
print(f"Final a: {a_param:.6f}, Final m: {m_param:.6f}")

# Code below shows output for (a, m) = (1, 0)

# Reset global_step so loss_fn prints debug info for this call
global_step = 0
fixed_a = 1.0
fixed_m = 0.0

comparison_loss = loss_fn(params, fixed_a, fixed_m)

print("\nComparison output for (a, m) = (1, 0):")
print(f"Loss: {qml.math.toarray(comparison_loss).item():.6f}")

